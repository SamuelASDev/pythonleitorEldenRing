import mss
import cv2
import numpy as np
import time
import pytesseract
import PySimpleGUI as sg

# --- Configurações do Tesseract (obrigatório se o Python não o encontrar automaticamente) ---
# Caminho real para o seu tesseract.exe.
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'


# --- Configurações Essenciais ---
# REGIÃO DE CAPTURA OTIMIZADA!
# Baseado na imagem que você enviou (1920x1080).
# Esta caixa engloba aproximadamente o texto "VOCÊ MORREU".
# Isso reduzirá MUITO o processamento do OCR, melhorando desempenho e precisão.
monitor = {
    "top": 480,
    "left": 650,          # 700 - 50
    "width": 620,          # 520 + 100
    "height": 80
}

# Lista de textos que indicam morte.
possible_death_texts = ["VOCE MORREU", "VOCÊ MORREU", "YOU DIED", "YOU DIED!"]

# Cooldown para evitar múltiplas contagens da mesma tela de morte (em segundos)
detection_cooldown = 1.5 # 1.5 segundos é um bom valor para a tela de morte de Elden Ring

# --- Configurações da GUI (PySimpleGUI) ---
# Posição do contador na tela (canto superior esquerdo da tela)
gui_location = (10, 10)
gui_font = ("Helvetica", 24, "bold")
gui_text_color = "red"
gui_background_color = "black" # Esta cor será transparente na janela da GUI

# --- Inicialização ---
sct = mss.mss()

# --- Configuração da Janela PySimpleGUI para o Contador ---
layout = [[sg.Text("Mortes: 0", size=(15, 1), font=gui_font, text_color=gui_text_color, key='-DEATH_COUNT-', background_color=gui_background_color)]]

window = sg.Window(
    'Elden Ring Death Counter', layout,
    no_titlebar=True, grab_anywhere=True, keep_on_top=True,
    transparent_color=gui_background_color,
    alpha_channel=0.8, # Define a transparência geral da janela (0.0 = totalmente transparente, 1.0 = totalmente opaca)
    location=gui_location, # Define a posição inicial da janela
    element_justification='center', # Centraliza o texto dentro do elemento sg.Text
    auto_size_text=True, # Ajusta automaticamente o tamanho do texto para caber
    return_keyboard_events=True # Para detectar eventos de teclado (como 'q' para sair)
)

print(f"Monitorando a região OTIMIZADA: {monitor['left']},{monitor['top']} até {monitor['left']+monitor['width']},{monitor['top']+monitor['height']}")
print(f"Pressione 'q' (na janela do contador) para sair. Monitorando a tela para os textos de morte...")

# --- Função de Detecção da Tela de Morte (VIA OCR) ---
def detect_death_screen_ocr(current_screen_bgr, target_texts_list):
    current_screen_gray = cv2.cvtColor(current_screen_bgr, cv2.COLOR_BGR2GRAY)
    img_for_ocr = current_screen_gray # O Tesseract geralmente se sai bem com escala de cinza

    try:
        text_extracted = pytesseract.image_to_string(img_for_ocr, lang='por+eng', config='--psm 6 --oem 3')

        # Processa o texto extraído para comparação
        processed_extracted_text = text_extracted.strip().upper().replace('\n', ' ').replace(' ', '')

        for death_word_phrase in target_texts_list:
            processed_target = death_word_phrase.strip().upper().replace(' ', '')
            if processed_target in processed_extracted_text:
                return True, text_extracted

        return False, text_extracted

    except pytesseract.TesseractNotFoundError:
        print("Erro: Tesseract OCR não encontrado. Verifique se o caminho em pytesseract.pytesseract.tesseract_cmd está correto.")
        return False, ""
    except Exception as e:
        print(f"Erro no OCR: {e}")
        return False, ""

# --- Variáveis para o Contador e Controle de Detecção ---
death_count = 0
is_death_screen_active = False # Flag para evitar múltiplas contagens
last_detected_time = 0 # Timer para o cooldown

# --- Loop Principal de Captura e Detecção ---
try:
    while True:
        event, values = window.read(timeout=10) # Lê eventos a cada 10ms
        if event == sg.WIN_CLOSED or event == 'q': # Se fechar a janela ou pressionar 'q'
            break

        # 1. Captura a tela (APENAS A REGIÃO OTIMIZADA!)
        sct_img = sct.grab(monitor)
        img_np = np.array(sct_img)

        if img_np.shape[2] == 4:
            img_np = cv2.cvtColor(img_np, cv2.COLOR_BGRA2BGR)

        # 2. Lógica de Detecção da Tela de Morte
        detected, ocr_text_raw = detect_death_screen_ocr(img_np, possible_death_texts)

        # --- DEBUG: Removido o print constante do texto lido. ---
        # Agora, o print só ocorre quando uma morte é realmente detectada.
        # if ocr_text_raw.strip():
        #    print(f"OCR leu: '{ocr_text_raw.strip()}'")
        # --- FIM DEBUG ---

        current_time = time.time()
        if detected and not is_death_screen_active and (current_time - last_detected_time > detection_cooldown):
            death_count += 1
            is_death_screen_active = True
            last_detected_time = current_time

            # Este print continuará funcionando, pois está dentro da condição 'if detected'
            print(f"!!! TELA DE MORTE DETECTADA VIA OCR !!! Mortes: {death_count} (Texto Lido: '{ocr_text_raw.strip()}')")
            window['-DEATH_COUNT-'].update(f"Mortes: {death_count}")

        elif not detected and is_death_screen_active:
            is_death_screen_active = False

        time.sleep(0.05) # Mantém 20 FPS

except Exception as e:
    print(f"Ocorreu um erro: {e}")
    import traceback
    traceback.print_exc()
finally:
    cv2.destroyAllWindows()
    window.close()
    print("Programa finalizado.")
    print(f"Total de mortes detectadas: {death_count}")